{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _extends from\"@babel/runtime/helpers/extends\";import _toArray from\"@babel/runtime/helpers/toArray\";import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import pathToRegexp from'path-to-regexp';var compilePathToRegex=function compilePathToRegex(path){var keys=[];var re=pathToRegexp(path,keys);return{re:re,keys:keys};};export var matchPath=function matchPath(path,url){var _url$split=url.split('?'),_url$split2=_slicedToArray(_url$split,1),urlCleaned=_url$split2[0];var urlToMatch=!urlCleaned.endsWith('/')?urlCleaned+\"/\":urlCleaned;var _compilePathToRegex=compilePathToRegex(path),re=_compilePathToRegex.re,keys=_compilePathToRegex.keys;var match=re.exec(urlToMatch);if(!match){return null;}var _match=_toArray(match),compiledUrl=_match[0],values=_match.slice(1);if(urlToMatch!==compiledUrl){return null;}var params=keys.reduce(function(acc,key,index){return _extends({},acc,_defineProperty({},key.name,values[index]));},{});return{path:path,params:params};};var pathParser=function pathParser(url){var possibleMatchingpaths=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];return possibleMatchingpaths.map(function(path){return matchPath(path,url);}).find(function(obj){return obj;});};export default pathParser;","map":{"version":3,"sources":["/home/thecoder/Documentos/UVG/Ecofiltro/waterProject/node_modules/react-native-router-flux/src/pathParser.js"],"names":["pathToRegexp","compilePathToRegex","path","keys","re","matchPath","url","split","urlCleaned","urlToMatch","endsWith","match","exec","compiledUrl","values","params","reduce","acc","key","index","name","pathParser","possibleMatchingpaths","map","find","obj"],"mappings":"8OAAA,MAAOA,CAAAA,YAAP,KAAyB,gBAAzB,CAgCA,GAAMC,CAAAA,kBAAkB,CAAG,QAArBA,CAAAA,kBAAqB,CAACC,IAAD,CAAU,CACnC,GAAMC,CAAAA,IAAI,CAAG,EAAb,CACA,GAAMC,CAAAA,EAAE,CAAGJ,YAAY,CAACE,IAAD,CAAOC,IAAP,CAAvB,CAGA,MAAO,CAAEC,EAAE,CAAFA,EAAF,CAAMD,IAAI,CAAJA,IAAN,CAAP,CACD,CAND,CAkCA,MAAO,IAAME,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,CAACH,IAAD,CAAOI,GAAP,CAAe,gBAGjBA,GAAG,CAACC,KAAJ,CAAU,GAAV,CAHiB,0CAG/BC,UAH+B,gBAMtC,GAAMC,CAAAA,UAAU,CAAG,CAACD,UAAU,CAACE,QAAX,CAAoB,GAApB,CAAD,CAA+BF,UAA/B,KAA+CA,UAAlE,CANsC,wBASjBP,kBAAkB,CAACC,IAAD,CATD,CAS9BE,EAT8B,qBAS9BA,EAT8B,CAS1BD,IAT0B,qBAS1BA,IAT0B,CAYtC,GAAMQ,CAAAA,KAAK,CAAGP,EAAE,CAACQ,IAAH,CAAQH,UAAR,CAAd,CAGA,GAAI,CAACE,KAAL,CAAY,CACV,MAAO,KAAP,CACD,CAjBqC,oBAqBLA,KArBK,EAqB/BE,WArB+B,WAqBfC,MArBe,iBAyBtC,GAAIL,UAAU,GAAKI,WAAnB,CAAgC,CAC9B,MAAO,KAAP,CACD,CAED,GAAME,CAAAA,MAAM,CAAGZ,IAAI,CAACa,MAAL,CAAY,SAACC,GAAD,CAAMC,GAAN,CAAWC,KAAX,QAAqB,UAAc,EAAd,CAAkBF,GAAlB,oBAA0BC,GAAG,CAACE,IAA9B,CAAqCN,MAAM,CAACK,KAAD,CAA3C,EAArB,EAAZ,CAAwF,EAAxF,CAAf,CAEA,MAAO,CAAEjB,IAAI,CAAJA,IAAF,CAAQa,MAAM,CAANA,MAAR,CAAP,CACD,CAhCM,CA4CP,GAAMM,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CAACf,GAAD,KAAMgB,CAAAA,qBAAN,2DAA8B,EAA9B,OAAqCA,CAAAA,qBAAqB,CAACC,GAAtB,CAA0B,SAAArB,IAAI,QAAIG,CAAAA,SAAS,CAACH,IAAD,CAAOI,GAAP,CAAb,EAA9B,EAAwDkB,IAAxD,CAA6D,SAAAC,GAAG,QAAIA,CAAAA,GAAJ,EAAhE,CAArC,EAAnB,CAEA,cAAeJ,CAAAA,UAAf","sourcesContent":["import pathToRegexp from 'path-to-regexp';\n\n/**\n *\n * This set of functions are used to match a url with a uri path.\n * This functionality is based on the internals of React-Router's matchPath.\n * - https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/matchPath.md\n *\n */\n\n/**\n * This function accepts a uri path and returns a regex to match that path\n * against a url and an array of the keys extracted from that uri path\n *\n * @param {String} path - a uri path in standard template (https://tools.ietf.org/html/rfc6570)\n *\n * Sample Input: \"/user/:id/\"\n *\n * Sample Output:\n * {\n *     re: /^\\/user\\/([^\\/]+?)\\/(?:\\/(?=$))?/i,\n *     keys: [\n *         name: \"id\"\n *         delimiter: \"/\"\n *         optional: false\n *         partial: false\n *         path: \"[^\\/]+?\"\n *         prefix: \"/\"\n *         repeat: false,\n *     ]\n * }\n */\nconst compilePathToRegex = (path) => {\n  const keys = [];\n  const re = pathToRegexp(path, keys);\n  // Returns the regex path to match a uri path to an actual url\n  // and the keys that can be used to pull values from the url.\n  return { re, keys };\n};\n\n/**\n * This function accepts a uri path and an actual url. It determines whether\n * or not they match one another. If they do not match, the funtion returns null.\n * If they do match, then the function returns the path and the params parsed\n * from the url.\n *\n * @param {String} path - a uri path in standard template (https://tools.ietf.org/html/rfc6570)\n * @param {String} url - a url that may or may not match the given path\n *\n * Case 1 - path Does Not Match Url:\n *   Sample Input: (path: \"/edit/organization/(:id)\", url: \"/user/300002/\")\n *\n *   Sample Output: null\n *\n * Case 2 - path Does Match Url:\n *   Sample Input: (path: \"/user/:id/\", url: \"/user/300002/\")\n *\n *   Sample Output:\n *   {\n *       path: \"/user/:id/\",\n *       params: {\n *           id: \"300002\",\n *       }\n *   }\n *\n */\nexport const matchPath = (path, url) => {\n  // Remove possible query fragments, which are not supported by iOS and some\n  // versions of Anroid.\n  const [urlCleaned] = url.split('?');\n\n  // Append trailing slash for compatibility with pathToRegexp\n  const urlToMatch = !urlCleaned.endsWith('/') ? `${urlCleaned}/` : urlCleaned;\n\n  // Return the regex and the keys that can be parsed from a uri path.\n  const { re, keys } = compilePathToRegex(path);\n\n  // Check if the given url matches the uri path.\n  const match = re.exec(urlToMatch);\n\n  // If there is no match, then return null.\n  if (!match) {\n    return null;\n  }\n\n  // Destructure to return the compiled url (aka the reconstructed url based\n  // on the regex and the url parameters.\n  const [compiledUrl, ...values] = match;\n\n  // If there is an inexact match (aka the compiled path does not match the\n  // given url, then return null)\n  if (urlToMatch !== compiledUrl) {\n    return null;\n  }\n\n  const params = keys.reduce((acc, key, index) => Object.assign({}, acc, { [key.name]: values[index] }), {});\n\n  return { path, params };\n};\n\n/**\n * This function accepts an array of uri paths and a url. If there are no paths\n * in the array that match the given url, then the function will return null.\n * If there is at least one matching uri path, it will return the first\n * matching path and the parsed url parameters (the output from matchPath()).\n *\n * @param {Array} possibleMatchingpaths - an array of uri paths in standard template (https://tools.ietf.org/html/rfc6570)\n * @param {String} url - a url that may or may not match a given path\n *\n */\nconst pathParser = (url, possibleMatchingpaths = []) => possibleMatchingpaths.map(path => matchPath(path, url)).find(obj => obj);\n\nexport default pathParser;\n"]},"metadata":{},"sourceType":"module"}