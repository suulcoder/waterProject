{"ast":null,"code":"module.exports=pathToRegexp;module.exports.parse=parse;module.exports.compile=compile;module.exports.tokensToFunction=tokensToFunction;module.exports.tokensToRegExp=tokensToRegExp;var DEFAULT_DELIMITER='/';var DEFAULT_DELIMITERS='./';var PATH_REGEXP=new RegExp(['(\\\\\\\\.)','(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'].join('|'),'g');function parse(str,options){var tokens=[];var key=0;var index=0;var path='';var defaultDelimiter=options&&options.delimiter||DEFAULT_DELIMITER;var delimiters=options&&options.delimiters||DEFAULT_DELIMITERS;var pathEscaped=false;var res;while((res=PATH_REGEXP.exec(str))!==null){var m=res[0];var escaped=res[1];var offset=res.index;path+=str.slice(index,offset);index=offset+m.length;if(escaped){path+=escaped[1];pathEscaped=true;continue;}var prev='';var next=str[index];var name=res[2];var capture=res[3];var group=res[4];var modifier=res[5];if(!pathEscaped&&path.length){var k=path.length-1;if(delimiters.indexOf(path[k])>-1){prev=path[k];path=path.slice(0,k);}}if(path){tokens.push(path);path='';pathEscaped=false;}var partial=prev!==''&&next!==undefined&&next!==prev;var repeat=modifier==='+'||modifier==='*';var optional=modifier==='?'||modifier==='*';var delimiter=prev||defaultDelimiter;var pattern=capture||group;tokens.push({name:name||key++,prefix:prev,delimiter:delimiter,optional:optional,repeat:repeat,partial:partial,pattern:pattern?escapeGroup(pattern):'[^'+escapeString(delimiter)+']+?'});}if(path||index<str.length){tokens.push(path+str.substr(index));}return tokens;}function compile(str,options){return tokensToFunction(parse(str,options));}function tokensToFunction(tokens){var matches=new Array(tokens.length);for(var i=0;i<tokens.length;i++){if(typeof tokens[i]==='object'){matches[i]=new RegExp('^(?:'+tokens[i].pattern+')$');}}return function(data,options){var path='';var encode=options&&options.encode||encodeURIComponent;for(var i=0;i<tokens.length;i++){var token=tokens[i];if(typeof token==='string'){path+=token;continue;}var value=data?data[token.name]:undefined;var segment;if(Array.isArray(value)){if(!token.repeat){throw new TypeError('Expected \"'+token.name+'\" to not repeat, but got array');}if(value.length===0){if(token.optional)continue;throw new TypeError('Expected \"'+token.name+'\" to not be empty');}for(var j=0;j<value.length;j++){segment=encode(value[j],token);if(!matches[i].test(segment)){throw new TypeError('Expected all \"'+token.name+'\" to match \"'+token.pattern+'\"');}path+=(j===0?token.prefix:token.delimiter)+segment;}continue;}if(typeof value==='string'||typeof value==='number'||typeof value==='boolean'){segment=encode(String(value),token);if(!matches[i].test(segment)){throw new TypeError('Expected \"'+token.name+'\" to match \"'+token.pattern+'\", but got \"'+segment+'\"');}path+=token.prefix+segment;continue;}if(token.optional){if(token.partial)path+=token.prefix;continue;}throw new TypeError('Expected \"'+token.name+'\" to be '+(token.repeat?'an array':'a string'));}return path;};}function escapeString(str){return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g,'\\\\$1');}function escapeGroup(group){return group.replace(/([=!:$/()])/g,'\\\\$1');}function flags(options){return options&&options.sensitive?'':'i';}function regexpToRegexp(path,keys){if(!keys)return path;var groups=path.source.match(/\\((?!\\?)/g);if(groups){for(var i=0;i<groups.length;i++){keys.push({name:i,prefix:null,delimiter:null,optional:false,repeat:false,partial:false,pattern:null});}}return path;}function arrayToRegexp(path,keys,options){var parts=[];for(var i=0;i<path.length;i++){parts.push(pathToRegexp(path[i],keys,options).source);}return new RegExp('(?:'+parts.join('|')+')',flags(options));}function stringToRegexp(path,keys,options){return tokensToRegExp(parse(path,options),keys,options);}function tokensToRegExp(tokens,keys,options){options=options||{};var strict=options.strict;var start=options.start!==false;var end=options.end!==false;var delimiter=escapeString(options.delimiter||DEFAULT_DELIMITER);var delimiters=options.delimiters||DEFAULT_DELIMITERS;var endsWith=[].concat(options.endsWith||[]).map(escapeString).concat('$').join('|');var route=start?'^':'';var isEndDelimited=tokens.length===0;for(var i=0;i<tokens.length;i++){var token=tokens[i];if(typeof token==='string'){route+=escapeString(token);isEndDelimited=i===tokens.length-1&&delimiters.indexOf(token[token.length-1])>-1;}else{var capture=token.repeat?'(?:'+token.pattern+')(?:'+escapeString(token.delimiter)+'(?:'+token.pattern+'))*':token.pattern;if(keys)keys.push(token);if(token.optional){if(token.partial){route+=escapeString(token.prefix)+'('+capture+')?';}else{route+='(?:'+escapeString(token.prefix)+'('+capture+'))?';}}else{route+=escapeString(token.prefix)+'('+capture+')';}}}if(end){if(!strict)route+='(?:'+delimiter+')?';route+=endsWith==='$'?'$':'(?='+endsWith+')';}else{if(!strict)route+='(?:'+delimiter+'(?='+endsWith+'))?';if(!isEndDelimited)route+='(?='+delimiter+'|'+endsWith+')';}return new RegExp(route,flags(options));}function pathToRegexp(path,keys,options){if(path instanceof RegExp){return regexpToRegexp(path,keys);}if(Array.isArray(path)){return arrayToRegexp(path,keys,options);}return stringToRegexp(path,keys,options);}","map":{"version":3,"sources":["/home/thecoder/Documentos/UVG/Ecofiltro/waterProject/node_modules/react-native-router-flux/node_modules/path-to-regexp/index.js"],"names":["module","exports","pathToRegexp","parse","compile","tokensToFunction","tokensToRegExp","DEFAULT_DELIMITER","DEFAULT_DELIMITERS","PATH_REGEXP","RegExp","join","str","options","tokens","key","index","path","defaultDelimiter","delimiter","delimiters","pathEscaped","res","exec","m","escaped","offset","slice","length","prev","next","name","capture","group","modifier","k","indexOf","push","partial","undefined","repeat","optional","pattern","prefix","escapeGroup","escapeString","substr","matches","Array","i","data","encode","encodeURIComponent","token","value","segment","isArray","TypeError","j","test","String","replace","flags","sensitive","regexpToRegexp","keys","groups","source","match","arrayToRegexp","parts","stringToRegexp","strict","start","end","endsWith","concat","map","route","isEndDelimited"],"mappings":"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","sourcesContent":["/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/'\nvar DEFAULT_DELIMITERS = './'\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \":test(\\\\d+)?\" => [\"test\", \"\\d+\", undefined, \"?\"]\n  // \"(\\\\d+)\"  => [undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER\n  var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS\n  var pathEscaped = false\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      pathEscaped = true\n      continue\n    }\n\n    var prev = ''\n    var next = str[index]\n    var name = res[2]\n    var capture = res[3]\n    var group = res[4]\n    var modifier = res[5]\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1\n\n      if (delimiters.indexOf(path[k]) > -1) {\n        prev = path[k]\n        path = path.slice(0, k)\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n      pathEscaped = false\n    }\n\n    var partial = prev !== '' && next !== undefined && next !== prev\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = prev || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'\n    })\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index))\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (data, options) {\n    var path = ''\n    var encode = (options && options.encode) || encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined\n      var segment\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j], token)\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value), token)\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment\n        continue\n      }\n\n      if (token.optional) {\n        // Prepend partial segment prefixes.\n        if (token.partial) path += token.prefix\n\n        continue\n      }\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        pattern: null\n      })\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var start = options.start !== false\n  var end = options.end !== false\n  var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER)\n  var delimiters = options.delimiters || DEFAULT_DELIMITERS\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')\n  var route = start ? '^' : ''\n  var isEndDelimited = tokens.length === 0\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n      isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1\n    } else {\n      var capture = token.repeat\n        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'\n        : token.pattern\n\n      if (keys) keys.push(token)\n\n      if (token.optional) {\n        if (token.partial) {\n          route += escapeString(token.prefix) + '(' + capture + ')?'\n        } else {\n          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?'\n        }\n      } else {\n        route += escapeString(token.prefix) + '(' + capture + ')'\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += '(?:' + delimiter + ')?'\n\n    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'\n  } else {\n    if (!strict) route += '(?:' + delimiter + '(?=' + endsWith + '))?'\n    if (!isEndDelimited) route += '(?=' + delimiter + '|' + endsWith + ')'\n  }\n\n  return new RegExp(route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\n"]},"metadata":{},"sourceType":"script"}