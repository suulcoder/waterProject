{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import React from'react';import MapView from\"./MapView\";export var makeOverlays=function makeOverlays(features){var points=features.filter(function(f){return f.geometry&&(f.geometry.type==='Point'||f.geometry.type==='MultiPoint');}).map(function(feature){return makeCoordinates(feature).map(function(coordinates){return makeOverlay(coordinates,feature);});}).reduce(flatten,[]).map(function(overlay){return _objectSpread(_objectSpread({},overlay),{},{type:'point'});});var lines=features.filter(function(f){return f.geometry&&(f.geometry.type==='LineString'||f.geometry.type==='MultiLineString');}).map(function(feature){return makeCoordinates(feature).map(function(coordinates){return makeOverlay(coordinates,feature);});}).reduce(flatten,[]).map(function(overlay){return _objectSpread(_objectSpread({},overlay),{},{type:'polyline'});});var multipolygons=features.filter(function(f){return f.geometry&&f.geometry.type==='MultiPolygon';}).map(function(feature){return makeCoordinates(feature).map(function(coordinates){return makeOverlay(coordinates,feature);});}).reduce(flatten,[]);var polygons=features.filter(function(f){return f.geometry&&f.geometry.type==='Polygon';}).map(function(feature){return makeOverlay(makeCoordinates(feature),feature);}).reduce(flatten,[]).concat(multipolygons).map(function(overlay){return _objectSpread(_objectSpread({},overlay),{},{type:'polygon'});});return points.concat(lines).concat(polygons);};var flatten=function flatten(prev,curr){return prev.concat(curr);};var makeOverlay=function makeOverlay(coordinates,feature){var overlay={feature:feature};if(feature.geometry.type==='Polygon'||feature.geometry.type==='MultiPolygon'){overlay.coordinates=coordinates[0];if(coordinates.length>1){overlay.holes=coordinates.slice(1);}}else{overlay.coordinates=coordinates;}return overlay;};var makePoint=function makePoint(c){return{latitude:c[1],longitude:c[0]};};var makeLine=function makeLine(l){return l.map(makePoint);};var makeCoordinates=function makeCoordinates(feature){var g=feature.geometry;if(g.type==='Point'){return[makePoint(g.coordinates)];}else if(g.type==='MultiPoint'){return g.coordinates.map(makePoint);}else if(g.type==='LineString'){return[makeLine(g.coordinates)];}else if(g.type==='MultiLineString'){return g.coordinates.map(makeLine);}else if(g.type==='Polygon'){return g.coordinates.map(makeLine);}else if(g.type==='MultiPolygon'){return g.coordinates.map(function(p){return p.map(makeLine);});}else{return[];}};var Geojson=function Geojson(props){var overlays=makeOverlays(props.geojson.features);return React.createElement(React.Fragment,null,overlays.map(function(overlay,index){if(overlay.type==='point'){return React.createElement(MapView.Marker,{key:index,coordinate:overlay.coordinates,pinColor:props.color});}if(overlay.type==='polygon'){return React.createElement(MapView.Polygon,{key:index,coordinates:overlay.coordinates,holes:overlay.holes,strokeColor:props.strokeColor,fillColor:props.fillColor,strokeWidth:props.strokeWidth});}if(overlay.type==='polyline'){return React.createElement(MapView.Polyline,{key:index,coordinates:overlay.coordinates,strokeColor:props.strokeColor,strokeWidth:props.strokeWidth});}}));};export default Geojson;","map":{"version":3,"sources":["/home/thecoder/Documentos/UVG/Ecofiltro/waterProject/node_modules/react-native-maps/lib/components/Geojson.js"],"names":["React","MapView","makeOverlays","features","points","filter","f","geometry","type","map","feature","makeCoordinates","coordinates","makeOverlay","reduce","flatten","overlay","lines","multipolygons","polygons","concat","prev","curr","length","holes","slice","makePoint","c","latitude","longitude","makeLine","l","g","p","Geojson","props","overlays","geojson","index","color","strokeColor","fillColor","strokeWidth"],"mappings":"+1BAAA,MAAOA,CAAAA,KAAP,KAAkB,OAAlB,CACA,MAAOC,CAAAA,OAAP,iBAEA,MAAO,IAAMC,CAAAA,YAAY,CAAG,QAAfA,CAAAA,YAAe,CAAAC,QAAQ,CAAI,CACtC,GAAMC,CAAAA,MAAM,CAAGD,QAAQ,CACpBE,MADY,CAEX,SAAAC,CAAC,QACCA,CAAAA,CAAC,CAACC,QAAF,GACCD,CAAC,CAACC,QAAF,CAAWC,IAAX,GAAoB,OAApB,EAA+BF,CAAC,CAACC,QAAF,CAAWC,IAAX,GAAoB,YADpD,CADD,EAFU,EAMZC,GANY,CAMR,SAAAC,OAAO,QACVC,CAAAA,eAAe,CAACD,OAAD,CAAf,CAAyBD,GAAzB,CAA6B,SAAAG,WAAW,QACtCC,CAAAA,WAAW,CAACD,WAAD,CAAcF,OAAd,CAD2B,EAAxC,CADU,EANC,EAWZI,MAXY,CAWLC,OAXK,CAWI,EAXJ,EAYZN,GAZY,CAYR,SAAAO,OAAO,wCAAUA,OAAV,MAAmBR,IAAI,CAAE,OAAzB,IAZC,CAAf,CAcA,GAAMS,CAAAA,KAAK,CAAGd,QAAQ,CACnBE,MADW,CAEV,SAAAC,CAAC,QACCA,CAAAA,CAAC,CAACC,QAAF,GACCD,CAAC,CAACC,QAAF,CAAWC,IAAX,GAAoB,YAApB,EACCF,CAAC,CAACC,QAAF,CAAWC,IAAX,GAAoB,iBAFtB,CADD,EAFS,EAOXC,GAPW,CAOP,SAAAC,OAAO,QACVC,CAAAA,eAAe,CAACD,OAAD,CAAf,CAAyBD,GAAzB,CAA6B,SAAAG,WAAW,QACtCC,CAAAA,WAAW,CAACD,WAAD,CAAcF,OAAd,CAD2B,EAAxC,CADU,EAPA,EAYXI,MAZW,CAYJC,OAZI,CAYK,EAZL,EAaXN,GAbW,CAaP,SAAAO,OAAO,wCAAUA,OAAV,MAAmBR,IAAI,CAAE,UAAzB,IAbA,CAAd,CAeA,GAAMU,CAAAA,aAAa,CAAGf,QAAQ,CAC3BE,MADmB,CACZ,SAAAC,CAAC,QAAIA,CAAAA,CAAC,CAACC,QAAF,EAAcD,CAAC,CAACC,QAAF,CAAWC,IAAX,GAAoB,cAAtC,EADW,EAEnBC,GAFmB,CAEf,SAAAC,OAAO,QACVC,CAAAA,eAAe,CAACD,OAAD,CAAf,CAAyBD,GAAzB,CAA6B,SAAAG,WAAW,QACtCC,CAAAA,WAAW,CAACD,WAAD,CAAcF,OAAd,CAD2B,EAAxC,CADU,EAFQ,EAOnBI,MAPmB,CAOZC,OAPY,CAOH,EAPG,CAAtB,CASA,GAAMI,CAAAA,QAAQ,CAAGhB,QAAQ,CACtBE,MADc,CACP,SAAAC,CAAC,QAAIA,CAAAA,CAAC,CAACC,QAAF,EAAcD,CAAC,CAACC,QAAF,CAAWC,IAAX,GAAoB,SAAtC,EADM,EAEdC,GAFc,CAEV,SAAAC,OAAO,QAAIG,CAAAA,WAAW,CAACF,eAAe,CAACD,OAAD,CAAhB,CAA2BA,OAA3B,CAAf,EAFG,EAGdI,MAHc,CAGPC,OAHO,CAGE,EAHF,EAIdK,MAJc,CAIPF,aAJO,EAKdT,GALc,CAKV,SAAAO,OAAO,wCAAUA,OAAV,MAAmBR,IAAI,CAAE,SAAzB,IALG,CAAjB,CAOA,MAAOJ,CAAAA,MAAM,CAACgB,MAAP,CAAcH,KAAd,EAAqBG,MAArB,CAA4BD,QAA5B,CAAP,CACD,CA/CM,CAiDP,GAAMJ,CAAAA,OAAO,CAAG,QAAVA,CAAAA,OAAU,CAACM,IAAD,CAAOC,IAAP,QAAgBD,CAAAA,IAAI,CAACD,MAAL,CAAYE,IAAZ,CAAhB,EAAhB,CAEA,GAAMT,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CAACD,WAAD,CAAcF,OAAd,CAA0B,CAC5C,GAAIM,CAAAA,OAAO,CAAG,CACZN,OAAO,CAAPA,OADY,CAAd,CAGA,GACEA,OAAO,CAACH,QAAR,CAAiBC,IAAjB,GAA0B,SAA1B,EACAE,OAAO,CAACH,QAAR,CAAiBC,IAAjB,GAA0B,cAF5B,CAGE,CACAQ,OAAO,CAACJ,WAAR,CAAsBA,WAAW,CAAC,CAAD,CAAjC,CACA,GAAIA,WAAW,CAACW,MAAZ,CAAqB,CAAzB,CAA4B,CAC1BP,OAAO,CAACQ,KAAR,CAAgBZ,WAAW,CAACa,KAAZ,CAAkB,CAAlB,CAAhB,CACD,CACF,CARD,IAQO,CACLT,OAAO,CAACJ,WAAR,CAAsBA,WAAtB,CACD,CACD,MAAOI,CAAAA,OAAP,CACD,CAhBD,CAkBA,GAAMU,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,CAAAC,CAAC,QAAK,CAAEC,QAAQ,CAAED,CAAC,CAAC,CAAD,CAAb,CAAkBE,SAAS,CAAEF,CAAC,CAAC,CAAD,CAA9B,CAAL,EAAnB,CAEA,GAAMG,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,CAAAC,CAAC,QAAIA,CAAAA,CAAC,CAACtB,GAAF,CAAMiB,SAAN,CAAJ,EAAlB,CAEA,GAAMf,CAAAA,eAAe,CAAG,QAAlBA,CAAAA,eAAkB,CAAAD,OAAO,CAAI,CACjC,GAAMsB,CAAAA,CAAC,CAAGtB,OAAO,CAACH,QAAlB,CACA,GAAIyB,CAAC,CAACxB,IAAF,GAAW,OAAf,CAAwB,CACtB,MAAO,CAACkB,SAAS,CAACM,CAAC,CAACpB,WAAH,CAAV,CAAP,CACD,CAFD,IAEO,IAAIoB,CAAC,CAACxB,IAAF,GAAW,YAAf,CAA6B,CAClC,MAAOwB,CAAAA,CAAC,CAACpB,WAAF,CAAcH,GAAd,CAAkBiB,SAAlB,CAAP,CACD,CAFM,IAEA,IAAIM,CAAC,CAACxB,IAAF,GAAW,YAAf,CAA6B,CAClC,MAAO,CAACsB,QAAQ,CAACE,CAAC,CAACpB,WAAH,CAAT,CAAP,CACD,CAFM,IAEA,IAAIoB,CAAC,CAACxB,IAAF,GAAW,iBAAf,CAAkC,CACvC,MAAOwB,CAAAA,CAAC,CAACpB,WAAF,CAAcH,GAAd,CAAkBqB,QAAlB,CAAP,CACD,CAFM,IAEA,IAAIE,CAAC,CAACxB,IAAF,GAAW,SAAf,CAA0B,CAC/B,MAAOwB,CAAAA,CAAC,CAACpB,WAAF,CAAcH,GAAd,CAAkBqB,QAAlB,CAAP,CACD,CAFM,IAEA,IAAIE,CAAC,CAACxB,IAAF,GAAW,cAAf,CAA+B,CACpC,MAAOwB,CAAAA,CAAC,CAACpB,WAAF,CAAcH,GAAd,CAAkB,SAAAwB,CAAC,QAAIA,CAAAA,CAAC,CAACxB,GAAF,CAAMqB,QAAN,CAAJ,EAAnB,CAAP,CACD,CAFM,IAEA,CACL,MAAO,EAAP,CACD,CACF,CAjBD,CAmBA,GAAMI,CAAAA,OAAO,CAAG,QAAVA,CAAAA,OAAU,CAAAC,KAAK,CAAI,CACvB,GAAMC,CAAAA,QAAQ,CAAGlC,YAAY,CAACiC,KAAK,CAACE,OAAN,CAAclC,QAAf,CAA7B,CACA,MACE,qBAAC,KAAD,CAAO,QAAP,MACGiC,QAAQ,CAAC3B,GAAT,CAAa,SAACO,OAAD,CAAUsB,KAAV,CAAoB,CAChC,GAAItB,OAAO,CAACR,IAAR,GAAiB,OAArB,CAA8B,CAC5B,MACE,qBAAC,OAAD,CAAS,MAAT,EACE,GAAG,CAAE8B,KADP,CAEE,UAAU,CAAEtB,OAAO,CAACJ,WAFtB,CAGE,QAAQ,CAAEuB,KAAK,CAACI,KAHlB,EADF,CAOD,CACD,GAAIvB,OAAO,CAACR,IAAR,GAAiB,SAArB,CAAgC,CAC9B,MACE,qBAAC,OAAD,CAAS,OAAT,EACE,GAAG,CAAE8B,KADP,CAEE,WAAW,CAAEtB,OAAO,CAACJ,WAFvB,CAGE,KAAK,CAAEI,OAAO,CAACQ,KAHjB,CAIE,WAAW,CAAEW,KAAK,CAACK,WAJrB,CAKE,SAAS,CAAEL,KAAK,CAACM,SALnB,CAME,WAAW,CAAEN,KAAK,CAACO,WANrB,EADF,CAUD,CACD,GAAI1B,OAAO,CAACR,IAAR,GAAiB,UAArB,CAAiC,CAC/B,MACE,qBAAC,OAAD,CAAS,QAAT,EACE,GAAG,CAAE8B,KADP,CAEE,WAAW,CAAEtB,OAAO,CAACJ,WAFvB,CAGE,WAAW,CAAEuB,KAAK,CAACK,WAHrB,CAIE,WAAW,CAAEL,KAAK,CAACO,WAJrB,EADF,CAQD,CACF,CAhCA,CADH,CADF,CAqCD,CAvCD,CAyCA,cAAeR,CAAAA,OAAf","sourcesContent":["import React from 'react';\nimport MapView from './MapView';\n\nexport const makeOverlays = features => {\n  const points = features\n    .filter(\n      f =>\n        f.geometry &&\n        (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint')\n    )\n    .map(feature =>\n      makeCoordinates(feature).map(coordinates =>\n        makeOverlay(coordinates, feature)\n      )\n    )\n    .reduce(flatten, [])\n    .map(overlay => ({ ...overlay, type: 'point' }));\n\n  const lines = features\n    .filter(\n      f =>\n        f.geometry &&\n        (f.geometry.type === 'LineString' ||\n          f.geometry.type === 'MultiLineString')\n    )\n    .map(feature =>\n      makeCoordinates(feature).map(coordinates =>\n        makeOverlay(coordinates, feature)\n      )\n    )\n    .reduce(flatten, [])\n    .map(overlay => ({ ...overlay, type: 'polyline' }));\n\n  const multipolygons = features\n    .filter(f => f.geometry && f.geometry.type === 'MultiPolygon')\n    .map(feature =>\n      makeCoordinates(feature).map(coordinates =>\n        makeOverlay(coordinates, feature)\n      )\n    )\n    .reduce(flatten, []);\n\n  const polygons = features\n    .filter(f => f.geometry && f.geometry.type === 'Polygon')\n    .map(feature => makeOverlay(makeCoordinates(feature), feature))\n    .reduce(flatten, [])\n    .concat(multipolygons)\n    .map(overlay => ({ ...overlay, type: 'polygon' }));\n\n  return points.concat(lines).concat(polygons);\n};\n\nconst flatten = (prev, curr) => prev.concat(curr);\n\nconst makeOverlay = (coordinates, feature) => {\n  let overlay = {\n    feature,\n  };\n  if (\n    feature.geometry.type === 'Polygon' ||\n    feature.geometry.type === 'MultiPolygon'\n  ) {\n    overlay.coordinates = coordinates[0];\n    if (coordinates.length > 1) {\n      overlay.holes = coordinates.slice(1);\n    }\n  } else {\n    overlay.coordinates = coordinates;\n  }\n  return overlay;\n};\n\nconst makePoint = c => ({ latitude: c[1], longitude: c[0] });\n\nconst makeLine = l => l.map(makePoint);\n\nconst makeCoordinates = feature => {\n  const g = feature.geometry;\n  if (g.type === 'Point') {\n    return [makePoint(g.coordinates)];\n  } else if (g.type === 'MultiPoint') {\n    return g.coordinates.map(makePoint);\n  } else if (g.type === 'LineString') {\n    return [makeLine(g.coordinates)];\n  } else if (g.type === 'MultiLineString') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'Polygon') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'MultiPolygon') {\n    return g.coordinates.map(p => p.map(makeLine));\n  } else {\n    return [];\n  }\n};\n\nconst Geojson = props => {\n  const overlays = makeOverlays(props.geojson.features);\n  return (\n    <React.Fragment>\n      {overlays.map((overlay, index) => {\n        if (overlay.type === 'point') {\n          return (\n            <MapView.Marker\n              key={index}\n              coordinate={overlay.coordinates}\n              pinColor={props.color}\n            />\n          );\n        }\n        if (overlay.type === 'polygon') {\n          return (\n            <MapView.Polygon\n              key={index}\n              coordinates={overlay.coordinates}\n              holes={overlay.holes}\n              strokeColor={props.strokeColor}\n              fillColor={props.fillColor}\n              strokeWidth={props.strokeWidth}\n            />\n          );\n        }\n        if (overlay.type === 'polyline') {\n          return (\n            <MapView.Polyline\n              key={index}\n              coordinates={overlay.coordinates}\n              strokeColor={props.strokeColor}\n              strokeWidth={props.strokeWidth}\n            />\n          );\n        }\n      })}\n    </React.Fragment>\n  );\n};\n\nexport default Geojson;\n"]},"metadata":{},"sourceType":"module"}